package jchess;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collection;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;


/**
 * Main file which handles the GUI.
 * @author Vassily
 */
public class JChess extends javax.swing.JFrame {

    private BufferedImageContainer pieceOverlay = new BufferedImageContainer();
    private BufferedImageContainer moveOverlay = new BufferedImageContainer();
    private chessBoard board = null;
    private pieceImage pieceIcons;
    private Point pressedLoc = null;
    private Point lastClicked = null;
    private comboColorMaker renderer;
    private colorSchemeSet colors;
    
    private boolean flipped = false;
    
    /**
     * Creates new form JChess
     */
    public JChess() {
        colors = new colorSchemeSet();
        renderer = new comboColorMaker(colors);
        pieceIcons = new pieceImage();
        Tools.loadColorSettings(colors);        

        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        Options = new javax.swing.JDialog();
        jLabel1 = new javax.swing.JLabel();
        jToggleButton1 = new javax.swing.JToggleButton();
        jComboBox1 = new javax.swing.JComboBox();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        colorCombo = new javax.swing.JComboBox();
        setFree = new javax.swing.JCheckBox();
        turn = new javax.swing.JLabel();
        newGame = new javax.swing.JButton();
        flip = new javax.swing.JButton();
        autoFlip = new javax.swing.JCheckBox();
        settings = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        centerPane = new javax.swing.JPanel();
        boardPane = new boardComponent(moveOverlay, pieceOverlay, colors);

        Options.setMinimumSize(new java.awt.Dimension(295, 349));
        Options.setResizable(false);

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("Options");
        jLabel1.setAlignmentX(0.5F);

        jToggleButton1.setText("Accept");
        jToggleButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jToggleButton1ActionPerformed(evt);
            }
        });

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        jLabel3.setText("Color Style");

        jLabel4.setText("Piece Style");

        renderer.setPreferredSize(colorCombo.getPreferredSize());
        colorCombo.setModel(new javax.swing.DefaultComboBoxModel(colors.getColorSets()));
        colorCombo.setRenderer(renderer);
        colorCombo.setSelectedItem(colors.getCurrentScheme());
        colorCombo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                colorComboActionPerformed(evt);
            }
        });

        setFree.setText("Free move");
        setFree.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        setFree.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                setFreeActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout OptionsLayout = new javax.swing.GroupLayout(Options.getContentPane());
        Options.getContentPane().setLayout(OptionsLayout);
        OptionsLayout.setHorizontalGroup(
            OptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(OptionsLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jToggleButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 118, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(OptionsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(OptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(OptionsLayout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addGap(18, 18, 18)
                        .addComponent(colorCombo, javax.swing.GroupLayout.PREFERRED_SIZE, 205, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(OptionsLayout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addGap(18, 18, 18)
                        .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 205, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addComponent(jLabel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(setFree, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        OptionsLayout.setVerticalGroup(
            OptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(OptionsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(54, 54, 54)
                .addGroup(OptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(colorCombo, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addGap(38, 38, 38)
                .addGroup(OptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel4))
                .addGap(18, 18, 18)
                .addComponent(setFree)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 36, Short.MAX_VALUE)
                .addComponent(jToggleButton1)
                .addContainerGap())
        );

        Options.setLocationRelativeTo(null);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("JChess Chess Player");
        setMinimumSize(new java.awt.Dimension(615, 550));
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });

        turn.setText("Move: ---");
        turn.setFont(new Font(Font.DIALOG,Font.BOLD,13));

        newGame.setText("New Game");
        newGame.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newGameActionPerformed(evt);
            }
        });

        flip.setText("Flip Board");
        flip.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                flipActionPerformed(evt);
            }
        });

        autoFlip.setText("Auto Flip");
        autoFlip.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                autoFlipActionPerformed(evt);
            }
        });

        settings.setText("Advanced Settings");
        settings.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                settingsActionPerformed(evt);
            }
        });

        jLabel2.setText("JChess V1.1");

        centerPane.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        centerPane.setName(""); // NOI18N
        centerPane.setOpaque(false);
        centerPane.setPreferredSize(new java.awt.Dimension(760, 760));
        centerPane.setVerifyInputWhenFocusTarget(false);
        centerPane.setLayout(null);

        boardPane.setAlignmentY(0.0F);
        boardPane.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                boardPaneMouseReleased(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                boardPaneMousePressed(evt);
            }
        });

        javax.swing.GroupLayout boardPaneLayout = new javax.swing.GroupLayout(boardPane);
        boardPane.setLayout(boardPaneLayout);
        boardPaneLayout.setHorizontalGroup(
            boardPaneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 760, Short.MAX_VALUE)
        );
        boardPaneLayout.setVerticalGroup(
            boardPaneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 760, Short.MAX_VALUE)
        );

        centerPane.add(boardPane);
        boardPane.setBounds(0, 0, 760, 760);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(jLabel2)
                        .addGap(18, 18, 18)
                        .addComponent(turn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(newGame, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(flip)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(autoFlip)
                        .addGap(18, 18, 18)
                        .addComponent(settings))
                    .addComponent(centerPane, javax.swing.GroupLayout.DEFAULT_SIZE, 835, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(newGame)
                    .addComponent(flip)
                    .addComponent(autoFlip)
                    .addComponent(settings)
                    .addComponent(jLabel2)
                    .addComponent(turn))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(centerPane, javax.swing.GroupLayout.DEFAULT_SIZE, 854, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void newGameActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newGameActionPerformed

        board = new chessBoard();
        turn.setText("Move: White");
        moveOverlay.newImage(boardPane.getWidth(), boardPane.getHeight());
        lastClicked = null;
        drawBoard();
        repaint();

    }//GEN-LAST:event_newGameActionPerformed

 
    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized


        lastClicked = null; // null var since overlay is cleared


        int dim = 0;
        if (centerPane.getWidth() < centerPane.getHeight()) {
            dim = centerPane.getWidth();
        } else {
            dim = centerPane.getHeight();
        }
        dim = dim - (dim % 8);
        boardPane.setSize(dim, dim);
        boardPane.setMaximumSize(new Dimension(dim, dim));


        boardPane.setLocation((centerPane.getWidth() - boardPane.getWidth()) / 2, 0);

        moveOverlay.newImage(boardPane.getWidth(), boardPane.getHeight()); // clear up move overlay so it isn't left over
        pieceOverlay.newImage(boardPane.getWidth(), boardPane.getHeight());
        drawBoard();


    }//GEN-LAST:event_formComponentResized

    private void autoFlipActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_autoFlipActionPerformed
        if (autoFlip.isSelected()) {
            flip.setEnabled(false);
        } else {
            flip.setEnabled(true);
        }
        
        // sets correct orientation for current move
        if(board.getTurn() == PColor.White){
            flipped = false;
        }else{
            flipped = true;
        }
        moveOverlay.newImage(1, 1);
        drawBoard();
        repaint();
    }//GEN-LAST:event_autoFlipActionPerformed

    private void settingsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_settingsActionPerformed
        Options.setVisible(true);
    }//GEN-LAST:event_settingsActionPerformed

    private void jToggleButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jToggleButton1ActionPerformed
        Options.setVisible(false);
    }//GEN-LAST:event_jToggleButton1ActionPerformed

    private void colorComboActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_colorComboActionPerformed
        colors.setCurrentScheme((String) colorCombo.getSelectedItem());
        drawBoard();
        repaint();
    }//GEN-LAST:event_colorComboActionPerformed

    private void boardPaneMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_boardPaneMousePressed
        if (board != null && evt.getButton() == MouseEvent.BUTTON1) {
            
            int x = evt.getPoint().x / (boardPane.getWidth() / 8) + 1;
            int y = evt.getPoint().y / (boardPane.getHeight() / 8) + 1;
            if (flipped){
                x = Tools.flip(x);
                y = Tools.flip(y);
            }
            pressedLoc = new Point(x, y);
        }
    }//GEN-LAST:event_boardPaneMousePressed

    private void boardPaneMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_boardPaneMouseReleased
        if (board != null && evt.getButton() == MouseEvent.BUTTON1) {
            int x = evt.getPoint().x / (boardPane.getWidth() / 8) + 1;
            int y = evt.getPoint().y / (boardPane.getHeight() / 8) + 1;
            if (flipped){
                x = Tools.flip(x);
                y = Tools.flip(y);
            }
            if (pressedLoc.equals(new Point(x, y))) {
                if (lastClicked == null && board.notEmpty(new Point(x, y))) { // no previous point - draw possible moves
                    lastClicked = new Point(x, y);
                    int tileSize = boardPane.getHeight() / 8;
                    moveOverlay.newImage(boardPane.getWidth(), boardPane.getHeight()); // rescale the overlay
                    Graphics2D drawer = moveOverlay.get().createGraphics();
                    drawer.setColor(colors.getColor(colorSchemeSet.Colors.HIGHLIGHT_1));
                    if(flipped){
                        drawer.fillRect((Tools.flip(x) - 1) * tileSize, (Tools.flip(y) - 1) * tileSize, tileSize, tileSize);
                    }else{
                        drawer.fillRect((x - 1) * tileSize, (y - 1) * tileSize, tileSize, tileSize);
                    }
                    Collection<Point> moves = board.getMoves(new Point(x, y));
                    
                    if(setFree.isSelected()){
                        // if freemove is set, then possibilities shouldn't be rendered.
                        moves = new ArrayList<>();
                    }
                    
                    drawer.setColor(colors.getColor(colorSchemeSet.Colors.HIGHLIGHT_2));
                    for (Point i : moves) {
                        int j;
                        int k;                     
                        if(flipped){
                            j = Tools.flip(i.x);
                            k = Tools.flip(i.y);
                        }else{
                           j = i.x;
                           k = i.y; 
                        }
                        
                        drawer.fillRect((j - 1) * tileSize, (k - 1) * tileSize, tileSize, tileSize);
                    }
                    drawer.dispose();
                } else if (lastClicked != null) { // move piece now

                    Status moved = board.movePiece(new Point(lastClicked.x, lastClicked.y), new Point(x, y)); //moves piece stores COMPLETION value
                    if (moved == Status.Success) {
                        turn.setText("Move: " + board.getTurn().name());
                        if(autoFlip.isSelected()){
                            flipped = !flipped;
                        }
                        moveOverlay.newImage(boardPane.getWidth(), boardPane.getHeight());
                        lastClicked = null;
                        drawBoard();

                    } else if (moved == Status.createsCheck) {
                        Point[] loc = board.checkLocationSim(lastClicked, new Point(x,y));
                        /*
                        Point[] loc = board.findCheckLocation(board.getTurn());
                        if (loc.length <= 1) {
                            // swtiching methods
                            loc = board.findAttackers(board.getTurn(), new Point(x, y));
                        }
                        * */
                        Alert(loc);


                    } else {
                        //invalid move, clear selection
                        moveOverlay.newImage(boardPane.getWidth(), boardPane.getHeight());
                        lastClicked = null;
                    }
                }
            }
        }
        pressedLoc = null;
        repaint();
    }//GEN-LAST:event_boardPaneMouseReleased

    private void setFreeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_setFreeActionPerformed
            board.setFreeMove(setFree.isSelected());
    }//GEN-LAST:event_setFreeActionPerformed

    private void flipActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_flipActionPerformed
        flipped = !flipped;
        moveOverlay.newImage(boardPane.getWidth(), boardPane.getHeight());
        pressedLoc = null;
        lastClicked = null;
        drawBoard();
        repaint();
    }//GEN-LAST:event_flipActionPerformed

    /**
     * Redraws the pieceOverlay.
     * Should be called with repaint().
     */
    private void drawBoard() {

        pieceIcons.rescale((int) (boardPane.getHeight() / 8 * 0.9));
        pieceOverlay.newImage(boardPane.getWidth(), boardPane.getHeight()); // rescale the overlay
        Graphics2D drawer = pieceOverlay.get().createGraphics();
        if (board != null) { //check if game has started
            for (int x = 0; x < 8; x++) {
                for (int y = 0; y < 8; y++) {
                    PType current = board.getType(new Point(x + 1, y + 1));
                    if (current != null) { //checking for empty slot
                        BufferedImage insert = pieceIcons.getImage(current);
                        
                        
                        int YOffset;
                        int XOffset;
                        if(flipped){
                            YOffset = (int) (boardPane.getHeight() / 8 - boardPane.getHeight() / 8 * 0.95) + (boardPane.getHeight() / 8 * (Tools.flip(y)-2));
                            XOffset = (int) ((boardPane.getWidth() / 8 - insert.getWidth()) / 2.0) + (boardPane.getWidth() / 8 * (Tools.flip(x)-2));
                        }else{
                            YOffset = (int) (boardPane.getHeight() / 8 - boardPane.getHeight() / 8 * 0.95) + (boardPane.getHeight() / 8 * y);
                            XOffset = (int) ((boardPane.getWidth() / 8 - insert.getWidth()) / 2.0) + (boardPane.getWidth() / 8 * x);
                        }
                        drawer.drawImage(insert, XOffset, YOffset, null);
                    }
                }
            }
        }
        drawer.dispose(); // dispose of graphics when done. IMPORTANT!

    }

    /**
     * Draws an alert on the moveOverlay.
     * used to draw check locations.
     * @param points Locations to highlight.
     */
    private void Alert(Point[] points) {

        Graphics2D drawer = moveOverlay.get().createGraphics();
        int height = moveOverlay.get().getHeight() / 8;
        int width = moveOverlay.get().getWidth() / 8;

        for (Point i : points) {
            drawer.setColor(colors.getColor(colorSchemeSet.Colors.ALERT));
            if(flipped){
                drawer.fillRect(width * (Tools.flip(i.x) - 1), width * (Tools.flip(i.y) - 1), width, height);
            }else{
                drawer.fillRect(width * (i.x - 1), width * (i.y - 1), width, height);
            }
            
        }
        repaint();
        drawer.dispose();
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
            Logger.getLogger(JChess.class.getName()).log(Level.SEVERE, null, ex);
        }

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new JChess().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JDialog Options;
    private javax.swing.JCheckBox autoFlip;
    private javax.swing.JPanel boardPane;
    private javax.swing.JPanel centerPane;
    private javax.swing.JComboBox colorCombo;
    private javax.swing.JButton flip;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JToggleButton jToggleButton1;
    private javax.swing.JButton newGame;
    private javax.swing.JCheckBox setFree;
    private javax.swing.JButton settings;
    private javax.swing.JLabel turn;
    // End of variables declaration//GEN-END:variables
}
